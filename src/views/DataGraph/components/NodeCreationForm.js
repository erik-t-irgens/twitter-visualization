import React from 'react';
import {
    Button,
    Divider,
    Form,
    Segment,
    Icon
} from 'semantic-ui-react';
import { addNode, removeNode } from "../../../actions/index";
import { connect } from "react-redux";

class NodeCreationForm extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            visible: this.props.visible,
            data: this.props.data,
            advancedOptions: false,
            // If a source isn't chosen
            errorStatement: false,
            // these options are the built-in sigma options for edge and node rendering shapes and colors.
            lineTypeOptions: [
                { key: 'l', text: 'Line', value: 'line' },
                { key: 'a', text: 'Arrow', value: 'arrow' },
                { key: 'c', text: 'Curve', value: 'curve' },
                { key: 'ca', text: 'Curved Arrow', value: 'curvedarrow' },
                { key: 'd', text: 'Dashed', value: 'dashed' },
                { key: 'dot', text: 'Dotted', value: 'dotted' },
                { key: 'p', text: 'Parallel', value: 'parallel' },
                { key: 't', text: 'Tapered', value: 'tapered' },
            ],
            // Desaturated version of the theme colors
            colorOptions: [
                { key: 'w', text: 'White', value: '#ffffff' },
                { key: 'p', text: 'Pink', value: '#b43c7c' },
                { key: 'y', text: 'Yellow', value: '#d4a325' },
                { key: 'pr', text: 'Purple', value: '#923cb4' },
                { key: 'b', text: 'Blue', value: '#2e9ab8' },
                { key: 'r', text: 'Red', value: '#d14751' },
                { key: 'g', text: 'Green', value: '#8ac44f' },
            ],
            nodeShapeOptions: [
                { key: 'd', text: 'Default (Circle)', value: 'def' },
                { key: 'p', text: 'Pacman', value: 'pacman' },
                { key: 's', text: 'Star', value: 'star' },
                { key: 'e', text: 'Triangle', value: 'equilateral' },
                { key: 'c', text: 'Cross', value: 'cross' },
                { key: 'dia', text: 'Diamond', value: 'diamond' },
                { key: 'ci', text: 'Circle', value: 'circle' },
                { key: 'sq', text: 'Square', value: 'square' },
            ],
            // Generated from possible children of a node.
            nodeSourceOptions: [
                // { key: 'e', text: 'Ex.', value: 'Ex.' },
            ]
        }
    }

    // Allows user to assign colors and shapes apart from defaults (defaults are inherited by the parent, assigned in the Sigma settings parameter in index, or can also be hard-coded in the node object itself (as seen in First,Second,Third party nodes))
    handleToggleAdvancedOptions = () => {
        this.setState({ advancedOptions: !this.state.advancedOptions })
    }

    // Create a unique ID, used for nodeId and edgeTarget (the same item)
    handleUniqueIdentifier = () => {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // This sets, in state, a name: value, which is generated by all input field types.
    handleChange = (e, { name, value }) => {
        this.setState({ [name]: value })
    }


    // TODO : Eventually, this should asynchronously call the pertinent data that a specific node contains. It needs to call the node's (that's being added) string, and then return the correct STRING. Unfortunately, these labels' styles are dictate by the Sigma component, and are less editable.
    handleCallLabelAPI = (labelApiUrl) => {
        // call API wit this labelApiURL. Instead, I have a placeholder. 
        const randomNumber = Math.floor((Math.random() * 999))
        const sizeIndicator = ["Bytes", "MegaBytes", "GigaBytes", "TeraBytes", "PetaBytes"]
        const randomSizeIndicator = sizeIndicator[Math.floor(Math.random() * 5)]
        let result = randomNumber + " " + " " + randomSizeIndicator
        return (result)

    }

    // NOTE: This should basically make sure all state is set appropriately, before doing something with the state. It needs to be sent up to the parent to create a new node.
    handleSubmit = () => {
        const { data, nodeSource, nodeColor, nodeShape, edgeType, edgeColor, edgeSource } = this.state

        if (nodeSource != this.props.data.node.label) {
            this.setState({
                nodeSource: nodeSource,
                nodeColor: nodeColor,
                nodeShape: nodeShape,
                edgeType: edgeType,
                edgeColor: edgeColor,
                edgeSource: data.node.id,
                nodeParty: data.node.party,
            })

            // Check to see if some properties exist already when creeating the payload. IF they do, add them to the payload. Otherwise, use the user's settings.
            const nodeToBeAdded = this.props.data.node.possibleChildren.find(node => node.label === nodeSource)

            const graphPayload = {
                node: {
                    ...this.props.data.node.possibleChildren.find(node => node.label === nodeSource),
                    id: this.state.nodeId,
                    label: nodeSource,

                    // Appropriately size nodes based on their parent's current size. Will not be anything smaller than 3. Anything below 5 will not display the node's title at default zoom. This keeps it from cluttering up.
                    size: this.props.data.node.size > 3 ? this.props.data.node.size - 2 : 3,
                    color: nodeToBeAdded.color || nodeColor,
                    type: nodeToBeAdded.type || nodeShape,
                    // This will set the party of the new node to its parent's party.
                    party: nodeToBeAdded.party || data.node.party,

                },
                edge: {
                    id: edgeSource + this.state.nodeId,
                    source: edgeSource,
                    target: this.state.nodeId,
                    type: edgeType,
                    color: edgeColor,
                    size: 3,
                    label: this.handleCallLabelAPI(nodeToBeAdded.labelApiUrl) || "No data"
                }
            }
            this.props.addNode(graphPayload)
            this.props.closeModal()
        } else {
            this.setState({ errorStatement: true })
        }
    }


    handleCreatePossibleChildNodes = () => {
        // Finds all displayed nodes' labels to compare to possible children labels
        let sigmaNodes = this.props.sigma.graph.nodes().map(n => n.label)
        //    Possible children are filtered down further to only allow for nodes that aren't already displayed. NOTE: the labels for every node MUST BE UNIQUE
        let possibleChildren = this.props.data.node.possibleChildren.filter(node => sigmaNodes.indexOf(node.label) < 0)
        // Instantiate
        let nodeFormOptions = []

        for (let i = 0; i < possibleChildren.length; i++) {
            nodeFormOptions.push({ key: this.handleUniqueIdentifier, text: possibleChildren[i].label, value: possibleChildren[i].label })
        }

        this.setState({
            nodeSourceOptions: [
                ...nodeFormOptions
            ]
        })
    }

    componentDidMount = () => {
        this.setState({ nodeSourceOptions: [], })
        this.handleCreatePossibleChildNodes()
        this.setState(
            {
                visible: this.props.visible,
                data: this.props.data,
            }
        )
        // Create a unique ID for the node, for pathing later with edges.
        const uniqueIdentifier = this.handleUniqueIdentifier()
        this.setState(
            {
                originNodeName: this.state.data.node.label,
                nodeSource: this.state.data.node.label,
                edgeSource: this.state.data.node.id,
                nodeId: uniqueIdentifier,
                edgeTarget: uniqueIdentifier,
                nodeColor: this.state.data.node.color,
            }
        )
    }

    render() {

        const { nodeShape, edgeColor, nodeColor, advancedOptions, lineTypeOptions, colorOptions, nodeShapeOptions, nodeSourceOptions, originNodeName, errorStatement } = this.state;
        return (
            <Segment inverted style={{
                position: "absolute",
                zIndex: 2,
                left: "50%",
                top: "50%",
                transform: "translate(-50%, -50%)",
                width: '40vw',
                maxWidth: '50vw',
                // minHeight: '50vh',
                maxHeight: '90vh',
                overflow: 'auto',
                textAlign: 'center'
            }}
            >
                <Icon style={{ cursor: 'pointer', left: '100%', right: 0, top: 0, position: 'sticky' }} onClick={this.props.closeModal} name='x' />

                {nodeSourceOptions < 1 ? <h3 style={{ marginBottom: '10%' }}>All possible nodes have been added.</h3> :

                    <Form style={{ textAlign: 'center' }} >
                        <h2>Attach node to "{originNodeName}"</h2>
                        <h3 style={{ left: '50%', translate: "transform (-50%, -50%)" }}>Node Settings</h3>

                        <Form.Group widths="equal">
                            <label style={{ color: 'white' }}>Data Source</label>
                            {!errorStatement ? <Form.Select
                                fluid
                                name="nodeSource"
                                required
                                options={nodeSourceOptions}
                                onChange={this.handleChange}
                                placeholder='Source...'
                            /> :
                                <Form.Select
                                    error={{
                                        content: 'You must select a source',
                                        pointing: 'above',
                                    }}
                                    fluid
                                    name="nodeSource"
                                    required
                                    options={nodeSourceOptions}
                                    onChange={this.handleChange}
                                    placeholder='Source...'
                                />}

                        </Form.Group>
                        {advancedOptions ?
                            <>
                                <Form.Group widths="equal">
                                    <label style={{ color: 'white' }}>Shape</label>
                                    <Form.Select
                                        fluid
                                        name="nodeShape"
                                        value={nodeShape}
                                        options={nodeShapeOptions}
                                        onChange={this.handleChange}
                                        placeholder='Shape...'
                                    />

                                    <label style={{ color: 'white' }}>Color</label>
                                    <Form.Select
                                        fluid
                                        name="nodeColor"
                                        value={nodeColor}
                                        options={colorOptions}
                                        onChange={this.handleChange}
                                        placeholder='Color...'
                                    />
                                </Form.Group>
                                {nodeColor ?
                                    <div style={{ marginBottom: '25px', backgroundColor: nodeColor, width: '100%', height: '25px', textAlign: 'center' }}>
                                        <p style={{ textShadow: '2px 2px 2px black' }}>Selected Color</p>
                                    </div> :
                                    null}
                                <Divider />
                                <h3 style={{ left: '50%', translate: "transform (-50%, -50%)", width: "100%" }}>Line Settings</h3>

                                <Form.Group widths="equal">
                                    <label style={{ color: 'white' }}>Style</label>
                                    <Form.Select
                                        fluid
                                        name="edgeType"
                                        options={lineTypeOptions}
                                        onChange={this.handleChange}
                                        placeholder='Style...'
                                    />

                                    <label style={{ color: 'white' }}>Color</label>
                                    <Form.Select
                                        fluid
                                        name="edgeColor"
                                        value={edgeColor}
                                        options={colorOptions}
                                        onChange={this.handleChange}
                                        placeholder='Color...'
                                    />

                                </Form.Group>
                                {edgeColor ?
                                    <div style={{ marginBottom: '25px', backgroundColor: edgeColor, width: '100%', height: '25px', textAlign: 'center' }}>
                                        <p style={{ textShadow: '2px 2px 2px black' }}>Selected Color</p>
                                    </div> :
                                    null
                                }
                            </> :
                            null
                        }

                        <Button inverted onClick={this.handleToggleAdvancedOptions}>
                            {advancedOptions ? 'Hide Advanced Options' : 'Show Advanced Options'}
                        </Button>
                        <Button onClick={this.handleSubmit} positive content='Add Node' />
                    </Form>
                }
            </Segment>
        )
    }
}

function mapStateToProps({ dashboardGraph }) {
    return { dashboardGraph };
}

const mapDispatchToProps = {
    addNode, removeNode
}

export default connect(mapStateToProps, mapDispatchToProps)(NodeCreationForm);